{
  "name": "Swift's Yolo! Operator",
  "tagline": "Be safe.",
  "body": "What is Swift's Yolo! operator? Simply put, this is the bang `!` operator used to force-unwrap optionals. We've all done it -- don't lie. When practicing safe yolo, the Yolo! operator can be a fun, healthy way to write code. So are you practicing safe yolo?\r\n\r\n# Why \"Yolo\"?\r\nWhen an optional variable is force-unwrapped \"unsafely\", we are telling the compiler \"Hey bro, don't worry about this variable -- I know better than you do. Yolo. ¬Ø\\_(„ÉÑ)_/¬Ø\" This is the programming-equivalent of \"here, hold my beer -- watch this\". You will get to know this line of code shortly because there is an excellent chance you will see it again in a crash report with the name `EXC_BREAKPOINT`.\r\n\r\n# Type of Yolo\r\n## ‚ö†Ô∏è Safe Yolo\r\n\"Safe\" yolo is using force-unwrap in places where the only reason it should crash your application is because of a programming or \"developer\" error. It is a contractual agreement you are entering into with the compiler that you know what's up. A calculated risk.\r\n\r\n## üí• Unsafe Yolo\r\nUnsafe yolo is force-unwrapping optionals because you \"need a non-optional\" or \"this will never be nil\". If it will \"never be nil\", then make it a non-optional -- it's an optional for a reason. Using yolo unsafely should be met with the assumption that when something goes wrong, the \"expected behavior\" is to crash. Good thing you know every single failure path in your application, because you've just opted the compiler out of caring about it.\r\n\r\n## ‚úÖ Mitigated Yolo\r\nMitigated yolo is yolo that has been removed in favor of proper use of either formally optional/non-optional storage. This allows the compiler to completely fact-check your work automatically, at least for expectations around object initialization. Normally these cases require explicit error handling around \"failure\" cases when optionals are nil.\r\n\r\n## üò± Silent Yolo\r\nMitigated yolo cases in which a formal optional has been used, but your nil failure cases are left entirely un-handled.\r\n\r\n# Some Examples of Yolo\r\n\r\n## Storyboard Unpacking\r\nLet's get this one out of the way since it's going to come up. When you create an IBOutlet from a storyboard or a xib, Xcode will create this gem:\r\n\r\n``` swift\r\n@IBOutlet weak var MyButton: UIButton!\r\n```\r\n\r\n‚ö†Ô∏è This is as \"safe\" yolo as you are going to get as the storyboard unpacking system has more knowledge about the system it is building than the compiler does. If these variables are nil when you try and access them, there are only a few possibilities:\r\n\r\n1. You are accessing them before `awakeFromNib` has been called\r\n2. You didn't connect that `IBOutlet` to your storyboard\r\n\r\nThese are both _programmer errors_ and _should_ crash your application.\r\n\r\n## We are given an optional from... somewhere\r\nSomeone (of course not you) has indicated that some variable is \"optional\" and you want to pass it into a function that requires a non-optional parameter.\r\n\r\n### üí• Wrong\r\n``` swift\r\nfunc completionCallback(optionalObject: Any?, error: ErrorType?) {\r\n    guard error == nil else {\r\n        // handle the error\r\n        return\r\n    }\r\n \r\n    // do some processing\r\n    self.nonOptionalFunc(optional!)\r\n}\r\n```\r\n\r\n### ‚úÖ Right\r\n``` swift\r\nfunc completionCallback(optionalObject: Any?, error: ErrorType?) {\r\n    guard error == nil else {\r\n        // handle the error\r\n        return\r\n    }\r\n \r\n    if let unwrappedOptional = optional {\r\n        // do some processing\r\n        self.nonOptionalFunc(unwrappedOptional)\r\n    } else {\r\n        // explicitly handle this case since something clearly went wrong\r\n    }\r\n}\r\n```\r\n\r\n## Inline optionals\r\nThis is likely the most common occurrence of yolo in your codebase. _Something_ will break here at some point in the future. Go on, do a quick audit of your codebase for `!.`. I'll wait.\r\n\r\n\r\n\r\n### üí• Wrong\r\n``` swift\r\nlet width: CGFloat = self.imageCache.imageForKey(imageKey)!.size.width\r\n```\r\n\r\n### Right \r\nUnfortunately, you're probably not going to like this one very much. Depending on how important or \"required\" the result of the work you are performing, you'll have to handle it in a couple of different ways:\r\n\r\n#### ‚úÖ Explicitly\r\n``` swift\r\nlet width: CGFloat\r\nif let cachedImage = self.imageCache.imageForKey(imageKey) {\r\n    width = cachedImage.size.width\r\n} else {\r\n    // Handle \"failure\" here\r\n}\r\n```\r\n\r\n#### üò± Silently -- or, \"don't care yolo\"\r\n``` swift\r\nvar width: CGFloat = 0.0\r\nif let cachedImage = self.imageCache.imageForKey(imageKey) {\r\n    width = cachedImage.size.width\r\n}\r\n```\r\n\r\n## Weak Storage\r\nWhen defining storage properties using weak storage, you should _never_* yolo these properties. `weak` storage are auto-zeroing properties that can become nil at any time when their owners release them.\r\n\r\n### üí• Wrong\r\nSo by defining this in your class:\r\n``` swift\r\nweak var delegate: UITableViewDelegate!\r\n```\r\n\r\nYou are entering into a contract with the compiler that you cannot in any way fulfill without intimate knowledge of the owner of `delegate`.\r\n\r\n### ‚úÖ Right\r\nThis is a no-yolo situation that should be handled correctly with optionals:\r\n\r\n``` swift\r\nweak var delegate: UITableViewDelegate?\r\n```\r\n\r\n## Type Casting\r\n## Throwing Errors\r\nEven if this is \"temporary\" code -- both you and I know this will make it into production. You're entering into a contract here where failures that result from this function choking will be met with an application crash.\r\n\r\n### üí• Wrong\r\n``` swift\r\ntry! errorThrowingProcessing(ofObject: obj)\r\n```\r\n\r\n### ‚úÖ Right\r\n``` swift\r\ndo {\r\n    try errorThrowingProcessing(ofObject: obj)\r\n}\r\ncatch {\r\n    // Handle error or rethrow -- it was thrown for a reason\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}